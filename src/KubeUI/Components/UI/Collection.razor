@inherits ControlBase<TItem>
@typeparam TItem

<fieldset>
    <legend onmouseover="@(() => { base.SetHelp.Invoke(Parent.GetProperty(Name).GetSummary()); })">
        @Name.AddSpacesToSentence().TrimVersionNumbers()
        <a href="javascript:;" onclick="@((e) => Add())" title="Add New @GenericType.Name.AddSpacesToSentence().TrimVersionNumbers()"><i class="fa fa-plus"></i></a>
    </legend>
    <BlazorTable IsBordered="true" IsHovarable="true" IsSmall="true" IsStriped="true" IsResponsive="true">
        <TableHead TableHeadType="TableHeadType.Light">
            <tr>
                @if (GenericType == typeof(string))
                {
                    <th scope="col">Value</th>
                }
                else
                {
                    @foreach (var property in GenericType.GetProperties())
                    {
                        <th scope="col">@property.Name.AddSpacesToSentence().TrimVersionNumbers()</th>
                    }
                }
                <th scope="col">Actions</th>
            </tr>
        </TableHead>
        <tbody>
            @if (Value != null)
            {
                @for (int i = 0; i < (int)Type.GetProperty("Count").GetValue(Value); i++)
                {
                    object[] index = { i };
                    var item = Type.GetProperty("Item").GetValue(Value, index);

                    <tr>
                        @if (GenericType == typeof(string))
                        {
                            <td>
                                <input type="text" value="@((string)item)" onchange="@((e) => { Type.GetProperty("Item").SetValue(Value, e.Value, index); OnChange(e); })" class="form-control form-control-sm" />
                            </td>
                        }
                        else
                        {
                            foreach (var property in GenericType.GetProperties())
                            {
                                <td>
                                    <input type="text" value="@property.GetValue(item)" onchange="@((e) => OnChange(item, e.Value, property))" class="form-control form-control-sm" onmouseover="@(() => base.SetHelp.Invoke(property.GetSummary()))" />
                                </td>
                            }
                        }
                        <td style="width:20px; text-align: center">
                            <a href="javascript:;" onclick="@(() => { Delete((int)index[0]); })" title="Delete"><i class='fa fa-trash' aria-hidden='true'></i></a>
                        </td>
                    </tr>
                }
            }
        </tbody>
    </BlazorTable>
</fieldset>

@functions {

    [Parameter] private Type Type { get; set; }

    [Inject] ILogger<Collection<TItem>> Logger { get; set; }

    private Type GenericType { get; set; }

    private void OnChange(UIChangeEventArgs e)
    {
        ValueChanged.Invoke(Value);

        StateHasChanged();
    }

    protected override void OnInit()
    {
        if (Value == null)
        {
            Logger.LogTrace("Value is null {0}", Type);
        }

        GenericType = Type.GetTypeInfo().GenericTypeArguments[0];

        base.OnInit();
    }

    private void Add()
    {
        object newObj = null;

        if (GenericType == typeof(string))
        {
            newObj = String.Empty;
        }
        else
        {
            newObj = Activator.CreateInstance(GenericType);
        }

        object[] data = { newObj };

        Value.GetType().GetMethod("Add").Invoke(Value, data);

        StateHasChanged();
    }

    private void Delete(int Id)
    {
        object[] data = { Id };

        Value.GetType().GetMethod("RemoveAt").Invoke(Value, data);

        StateHasChanged();
    }

    protected void OnChange(Object dest, Object value, PropertyInfo prop)
    {
        try
        {
            if (prop.PropertyType == typeof(string))
            {
                prop.SetValue(dest, value == null ? null : value.ToString());
            }
            else if (prop.PropertyType == typeof(bool))
            {
                prop.SetValue(dest, bool.TryParse(value.ToString(), out var tmpvalue) ? tmpvalue : default(bool));
            }
            else if (prop.PropertyType == typeof(bool?))
            {
                prop.SetValue(dest, bool.TryParse(value.ToString(), out var tmpvalue) ? tmpvalue : (bool?)null);
            }
            else if (prop.PropertyType == typeof(int))
            {
                prop.SetValue(dest, int.TryParse(value.ToString(), out var tmpvalue) ? tmpvalue : default(int));
            }
            else if (prop.PropertyType == typeof(int?))
            {
                prop.SetValue(dest, int.TryParse(value.ToString(), out var tmpvalue) ? tmpvalue : (int?)null);
            }
            else if (prop.PropertyType == typeof(long))
            {
                prop.SetValue(dest, long.TryParse(value.ToString(), out var tmpvalue) ? tmpvalue : default(long));
            }
            else if (prop.PropertyType == typeof(long?))
            {
                prop.SetValue(dest, long.TryParse(value.ToString(), out var tmpvalue) ? tmpvalue : (long?)null);
            }
            else if (prop.PropertyType == typeof(IDictionary<string, string>))
            {
                prop.SetValue(dest, (IDictionary<string, string>)value);
            }
            else
            {
                throw new Exception("Type not supported!");
            }

            ValueChanged?.Invoke(Value);

            StateHasChanged();
        }
        catch (Exception ex)
        {
            Logger.LogError("Casting Error : {0} - {1} - {2}", value.GetType(), value, ex);
        }
    }

}
